import{j as k,h as b,S as nt,D as G,r as $,i as st}from"./main-t1m2ejxw.js";import{c as rt}from"./button-DvXn5wo_.js";function bt({className:r,...a}){return k.jsx("div",{"data-slot":"card",className:rt("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",r),...a})}function Et({className:r,...a}){return k.jsx("div",{"data-slot":"card-content",className:rt("px-6",r),...a})}function R(r,a){return typeof r=="function"?r(a):r}function P(r,a){return Y(a).reduce((i,e)=>{if(i===null)return null;if(typeof i<"u")return i[e]},r)}function j(r,a,t){const i=Y(a);function e(s){if(!i.length)return R(t,s);const o=i.shift();if(typeof o=="string"||typeof o=="number"&&!Array.isArray(s))return typeof s=="object"?(s===null&&(s={}),{...s,[o]:e(s[o])}):{[o]:e()};if(Array.isArray(s)&&typeof o=="number"){const l=s.slice(0,o);return[...l.length?l:new Array(o),e(s[o]),...s.slice(o+1)]}return[...new Array(o),e()]}return e(r)}function lt(r,a){const t=Y(a);function i(e){if(!e)return;if(t.length===1){const o=t[0];if(Array.isArray(e)&&typeof o=="number")return e.filter((m,h)=>h!==o);const{[o]:l,...d}=e;return d}const s=t.shift();if(typeof s=="string"&&typeof e=="object")return{...e,[s]:i(e[s])};if(typeof s=="number"&&Array.isArray(e)){if(s>=e.length)return e;const o=e.slice(0,s);return[...o.length?o:new Array(s),i(e[s]),...e.slice(s+1)]}throw new Error("It seems we have created an infinite loop in deleteBy. ")}return i(r)}const ut=/^(\d+)$/gm,ct=/\.(\d+)(?=\.)/gm,dt=/^(\d+)\./gm,ht=/\.(\d+$)/gm,ft=/\.{2,}/gm,q="__int__",W=`${q}$1`;function Y(r){if(Array.isArray(r))return[...r];if(typeof r!="string")throw new Error("Path must be a string.");return r.replace(/(^\[)|]/gm,"").replace(/\[/g,".").replace(ut,W).replace(ct,`.${W}.`).replace(dt,`${W}.`).replace(ht,`.${W}`).replace(ft,".").split(".").map(a=>{if(a.startsWith(q)){const t=a.substring(q.length),i=parseInt(t,10);return String(i)===t?i:t}return a})}function mt(r){return!(Array.isArray(r)&&r.length===0)}function J(r,a){const t=i=>i.validators.filter(Boolean).map(e=>({cause:e.cause,validate:e.fn}));return a.validationLogic({form:a.form,validators:a.validators,event:{type:r,async:!1},runValidation:t})}function Q(r,a){const{asyncDebounceMs:t}=a,{onBlurAsyncDebounceMs:i,onChangeAsyncDebounceMs:e,onDynamicAsyncDebounceMs:s}=a.validators||{},o=t??0,l=d=>d.validators.filter(Boolean).map(m=>{const h=m?.cause||r;let u=o;switch(h){case"change":u=e??o;break;case"blur":u=i??o;break;case"dynamic":u=s??o;break;case"submit":u=0;break}return r==="submit"&&(u=0),{cause:h,validate:m.fn,debounceMs:u}});return a.validationLogic({form:a.form,validators:a.validators,event:{type:r,async:!0},runValidation:l})}const X=r=>!!r&&typeof r=="object"&&"fields"in r;function D(r,a){if(Object.is(r,a))return!0;if(typeof r!="object"||r===null||typeof a!="object"||a===null)return!1;if(r instanceof Map&&a instanceof Map){if(r.size!==a.size)return!1;for(const[e,s]of r)if(!a.has(e)||!Object.is(s,a.get(e)))return!1;return!0}if(r instanceof Set&&a instanceof Set){if(r.size!==a.size)return!1;for(const e of r)if(!a.has(e))return!1;return!0}const t=Object.keys(r),i=Object.keys(a);if(t.length!==i.length)return!1;for(const e of t)if(!i.includes(e)||!D(r[e],a[e]))return!1;return!0}const Z=({newFormValidatorError:r,isPreviousErrorFromFormValidator:a,previousErrorValue:t})=>r?{newErrorValue:r,newSource:"form"}:a?{newErrorValue:void 0,newSource:void 0}:t?{newErrorValue:t,newSource:"field"}:{newErrorValue:void 0,newSource:void 0},tt=({formLevelError:r,fieldLevelError:a})=>a?{newErrorValue:a,newSource:"field"}:r?{newErrorValue:r,newSource:"form"}:{newErrorValue:void 0,newSource:void 0},O=r=>{if(!r.validators)return r.runValidation({validators:[],form:r.form});const a=r.event.async,t=a?void 0:{fn:r.validators.onMount,cause:"mount"},i={fn:a?r.validators.onChangeAsync:r.validators.onChange,cause:"change"},e={fn:a?r.validators.onBlurAsync:r.validators.onBlur,cause:"blur"},s={fn:a?r.validators.onSubmitAsync:r.validators.onSubmit,cause:"submit"},o=a?void 0:{fn:()=>{},cause:"server"};switch(r.event.type){case"mount":return r.runValidation({validators:[t],form:r.form});case"submit":return r.runValidation({validators:[i,e,s,o],form:r.form});case"server":return r.runValidation({validators:[],form:r.form});case"blur":return r.runValidation({validators:[e,o],form:r.form});case"change":return r.runValidation({validators:[i,o],form:r.form});default:throw new Error(`Unknown validation event type: ${r.event.type}`)}};function vt(r){const a=new Map;for(const t of r){const i=[...t.path??[]].map(e=>{const s=typeof e=="object"?e.key:e;return typeof s=="number"?`[${s}]`:s}).join(".").replace(/\.\[/g,"[");a.set(i,(a.get(i)??[]).concat(t))}return Object.fromEntries(a)}const et=r=>{const a=vt(r);return{form:a,fields:a}},T={validate({value:r,validationSource:a},t){const i=t["~standard"].validate(r);if(i instanceof Promise)throw new Error("async function passed to sync validator");if(i.issues)return a==="field"?i.issues:et(i.issues)},async validateAsync({value:r,validationSource:a},t){const i=await t["~standard"].validate(r);if(i.issues)return a==="field"?i.issues:et(i.issues)}},at=r=>!!r&&"~standard"in r,z={isValidating:!1,isTouched:!1,isBlurred:!1,isDirty:!1,isPristine:!0,isValid:!0,isDefaultValue:!0,errors:[],errorMap:{},errorSourceMap:{}};function _(r){function a(u,n,c,M){const f=i(u,n,c,M);({insert:()=>l(f,u,n),remove:()=>d(f),swap:()=>M!==void 0&&h(f,u,n,M),move:()=>M!==void 0&&m(f,u,n,M)})[c]()}function t(u,n){return`${u}[${n}]`}function i(u,n,c,M){const f=[t(u,n)];if(c==="swap")f.push(t(u,M));else if(c==="move"){const[v,g]=[Math.min(n,M),Math.max(n,M)];for(let p=v;p<=g;p++)f.push(t(u,p))}else{const v=r.getFieldValue(u),g=Array.isArray(v)?v.length:0;for(let p=n+1;p<g;p++)f.push(t(u,p))}return Object.keys(r.fieldInfo).filter(v=>f.some(g=>v.startsWith(g)))}function e(u,n){return u.replace(/\[(\d+)\]/,(c,M)=>{const f=parseInt(M,10);return`[${n==="up"?f+1:Math.max(0,f-1)}]`})}function s(u,n){(n==="up"?u:[...u].reverse()).forEach(M=>{const f=e(M.toString(),n),v=r.getFieldMeta(f);v?r.setFieldMeta(M,v):r.setFieldMeta(M,o())})}const o=()=>z,l=(u,n,c)=>{s(u,"down"),u.forEach(M=>{M.toString().startsWith(t(n,c))&&r.setFieldMeta(M,o())})},d=u=>{s(u,"up")},m=(u,n,c,M)=>{const f=new Map(Object.keys(r.fieldInfo).filter(v=>v.startsWith(t(n,c))).map(v=>[v,r.getFieldMeta(v)]));s(u,c<M?"up":"down"),Object.keys(r.fieldInfo).filter(v=>v.startsWith(t(n,M))).forEach(v=>{const g=v.replace(t(n,M),t(n,c)),p=f.get(g);p&&r.setFieldMeta(v,p)})},h=(u,n,c,M)=>{u.forEach(f=>{if(!f.toString().startsWith(t(n,c)))return;const v=f.toString().replace(t(n,c),t(n,M)),[g,p]=[r.getFieldMeta(f),r.getFieldMeta(v)];g&&r.setFieldMeta(v,g),p&&r.setFieldMeta(f,p)})};return{handleArrayFieldMetaShift:a}}function H(r){return{values:r.values??{},errorMap:r.errorMap??{},fieldMetaBase:r.fieldMetaBase??{},isSubmitted:r.isSubmitted??!1,isSubmitting:r.isSubmitting??!1,isValidating:r.isValidating??!1,submissionAttempts:r.submissionAttempts??0,isSubmitSuccessful:r.isSubmitSuccessful??!1,validationMetaMap:r.validationMetaMap??{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0,onDynamic:void 0}}}class Mt{constructor(a){this.options={},this.fieldInfo={},this.prevTransformArray=[],this.mount=()=>{const t=this.fieldMetaDerived.mount(),i=this.store.mount(),e=()=>{t(),i()};this.options.listeners?.onMount?.({formApi:this});const{onMount:s}=this.options.validators||{};return s&&this.validateSync("mount"),e},this.update=t=>{if(!t)return;const i=this.options;this.options=t;const e=!!t.transform?.deps?.some((l,d)=>l!==this.prevTransformArray[d]),s=t.defaultValues&&!D(t.defaultValues,i.defaultValues)&&!this.state.isTouched,o=!D(t.defaultState,i.defaultState)&&!this.state.isTouched;!s&&!o&&!e||b(()=>{this.baseStore.setState(()=>H(Object.assign({},this.state,o?t.defaultState:{},s?{values:t.defaultValues}:{},e?{_force_re_eval:!this.state._force_re_eval}:{})))})},this.reset=(t,i)=>{const{fieldMeta:e}=this.state,s=this.resetFieldMeta(e);t&&!i?.keepDefaultValues&&(this.options={...this.options,defaultValues:t}),this.baseStore.setState(()=>H({...this.options.defaultState,values:t??this.options.defaultValues??this.options.defaultState?.values,fieldMetaBase:s}))},this.validateAllFields=async t=>{const i=[];return b(()=>{Object.values(this.fieldInfo).forEach(s=>{if(!s.instance)return;const o=s.instance;i.push(Promise.resolve().then(()=>o.validate(t,{skipFormValidation:!0}))),s.instance.state.meta.isTouched||s.instance.setMeta(l=>({...l,isTouched:!0}))})}),(await Promise.all(i)).flat()},this.validateArrayFieldsStartingFrom=async(t,i,e)=>{const s=this.getFieldValue(t),o=Array.isArray(s)?Math.max(s.length-1,0):null,l=[`${t}[${i}]`];for(let u=i+1;u<=(o??0);u++)l.push(`${t}[${u}]`);const d=Object.keys(this.fieldInfo).filter(u=>l.some(n=>u.startsWith(n))),m=[];return b(()=>{d.forEach(u=>{m.push(Promise.resolve().then(()=>this.validateField(u,e)))})}),(await Promise.all(m)).flat()},this.validateField=(t,i)=>{const e=this.fieldInfo[t]?.instance;return e?(e.state.meta.isTouched||e.setMeta(s=>({...s,isTouched:!0})),e.validate(i)):[]},this.validateSync=t=>{const i=J(t,{...this.options,form:this,validationLogic:this.options.validationLogic||O});let e=!1;const s={};return b(()=>{for(const d of i){if(!d.validate)continue;const m=this.runValidator({validate:d.validate,value:{value:this.state.values,formApi:this,validationSource:"form"},type:"validate"}),{formError:h,fieldErrors:u}=U(m),n=C(d.cause);for(const c of Object.keys(this.state.fieldMeta)){const M=this.getFieldMeta(c);if(!M)continue;const{errorMap:f,errorSourceMap:v}=M,g=u?.[c],{newErrorValue:p,newSource:S}=Z({newFormValidatorError:g,isPreviousErrorFromFormValidator:v?.[n]==="form",previousErrorValue:f?.[n]});S==="form"&&(s[c]={...s[c],[n]:g}),f?.[n]!==p&&this.setFieldMeta(c,V=>({...V,errorMap:{...V.errorMap,[n]:p},errorSourceMap:{...V.errorSourceMap,[n]:S}}))}this.state.errorMap?.[n]!==h&&this.baseStore.setState(c=>({...c,errorMap:{...c.errorMap,[n]:h}})),(h||u)&&(e=!0)}const o=C("submit");this.state.errorMap?.[o]&&t!=="submit"&&!e&&this.baseStore.setState(d=>({...d,errorMap:{...d.errorMap,[o]:void 0}}));const l=C("server");this.state.errorMap?.[l]&&t!=="server"&&!e&&this.baseStore.setState(d=>({...d,errorMap:{...d.errorMap,[l]:void 0}}))}),{hasErrored:e,fieldsErrorMap:s}},this.validateAsync=async t=>{const i=Q(t,{...this.options,form:this,validationLogic:this.options.validationLogic||O});this.state.isFormValidating||this.baseStore.setState(d=>({...d,isFormValidating:!0}));const e=[];let s;for(const d of i){if(!d.validate)continue;const m=C(d.cause);this.state.validationMetaMap[m]?.lastAbortController.abort();const u=new AbortController;this.state.validationMetaMap[m]={lastAbortController:u},e.push(new Promise(async n=>{let c;try{c=await new Promise((g,p)=>{setTimeout(async()=>{if(u.signal.aborted)return g(void 0);try{g(await this.runValidator({validate:d.validate,value:{value:this.state.values,formApi:this,validationSource:"form",signal:u.signal},type:"validateAsync"}))}catch(S){p(S)}},d.debounceMs)})}catch(g){c=g}const{formError:M,fieldErrors:f}=U(c);f&&(s=s?{...s,...f}:f);const v=C(d.cause);for(const g of Object.keys(this.state.fieldMeta)){const p=this.getFieldMeta(g);if(!p)continue;const{errorMap:S,errorSourceMap:V}=p,A=s?.[g],{newErrorValue:E,newSource:L}=Z({newFormValidatorError:A,isPreviousErrorFromFormValidator:V?.[v]==="form",previousErrorValue:S?.[v]});S?.[v]!==E&&this.setFieldMeta(g,F=>({...F,errorMap:{...F.errorMap,[v]:E},errorSourceMap:{...F.errorSourceMap,[v]:L}}))}this.baseStore.setState(g=>({...g,errorMap:{...g.errorMap,[v]:M}})),n(s?{fieldErrors:s,errorMapKey:v}:void 0)}))}let o=[];const l={};if(e.length){o=await Promise.all(e);for(const d of o)if(d?.fieldErrors){const{errorMapKey:m}=d;for(const[h,u]of Object.entries(d.fieldErrors)){const c={...l[h]||{},[m]:u};l[h]=c}}}return this.baseStore.setState(d=>({...d,isFormValidating:!1})),l},this.validate=t=>{const{hasErrored:i,fieldsErrorMap:e}=this.validateSync(t);return i&&!this.options.asyncAlways?e:this.validateAsync(t)},this.getFieldValue=t=>P(this.state.values,t),this.getFieldMeta=t=>this.state.fieldMeta[t],this.getFieldInfo=t=>this.fieldInfo[t]||={instance:null,validationMetaMap:{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0,onDynamic:void 0}},this.setFieldMeta=(t,i)=>{this.baseStore.setState(e=>({...e,fieldMetaBase:{...e.fieldMetaBase,[t]:R(i,e.fieldMetaBase[t])}}))},this.resetFieldMeta=t=>Object.keys(t).reduce((i,e)=>{const s=e;return i[s]=z,i},{}),this.setFieldValue=(t,i,e)=>{const s=e?.dontUpdateMeta??!1;b(()=>{s||this.setFieldMeta(t,o=>({...o,isTouched:!0,isDirty:!0,errorMap:{...o?.errorMap,onMount:void 0}})),this.baseStore.setState(o=>({...o,values:j(o.values,t,i)}))})},this.deleteField=t=>{const e=[...Object.keys(this.fieldInfo).filter(s=>{const o=t.toString();return s!==o&&s.startsWith(o)}),t];this.baseStore.setState(s=>{const o={...s};return e.forEach(l=>{o.values=lt(o.values,l),delete this.fieldInfo[l],delete o.fieldMetaBase[l]}),o})},this.pushFieldValue=(t,i,e)=>{this.setFieldValue(t,s=>[...Array.isArray(s)?s:[],i],e),this.validateField(t,"change")},this.insertFieldValue=async(t,i,e,s)=>{this.setFieldValue(t,o=>[...o.slice(0,i),e,...o.slice(i)],s),await this.validateField(t,"change"),_(this).handleArrayFieldMetaShift(t,i,"insert"),await this.validateArrayFieldsStartingFrom(t,i,"change")},this.replaceFieldValue=async(t,i,e,s)=>{this.setFieldValue(t,o=>o.map((l,d)=>d===i?e:l),s),await this.validateField(t,"change"),await this.validateArrayFieldsStartingFrom(t,i,"change")},this.removeFieldValue=async(t,i,e)=>{const s=this.getFieldValue(t),o=Array.isArray(s)?Math.max(s.length-1,0):null;if(this.setFieldValue(t,l=>l.filter((d,m)=>m!==i),e),_(this).handleArrayFieldMetaShift(t,i,"remove"),o!==null){const l=`${t}[${o}]`;this.deleteField(l)}await this.validateField(t,"change"),await this.validateArrayFieldsStartingFrom(t,i,"change")},this.swapFieldValues=(t,i,e,s)=>{this.setFieldValue(t,o=>{const l=o[i],d=o[e];return j(j(o,`${i}`,d),`${e}`,l)},s),_(this).handleArrayFieldMetaShift(t,i,"swap",e),this.validateField(t,"change"),this.validateField(`${t}[${i}]`,"change"),this.validateField(`${t}[${e}]`,"change")},this.moveFieldValues=(t,i,e,s)=>{this.setFieldValue(t,o=>{const l=[...o];return l.splice(e,0,l.splice(i,1)[0]),l},s),_(this).handleArrayFieldMetaShift(t,i,"move",e),this.validateField(t,"change"),this.validateField(`${t}[${i}]`,"change"),this.validateField(`${t}[${e}]`,"change")},this.clearFieldValues=(t,i)=>{const e=this.getFieldValue(t),s=Array.isArray(e)?Math.max(e.length-1,0):null;if(this.setFieldValue(t,[],i),s!==null)for(let o=0;o<=s;o++){const l=`${t}[${o}]`;this.deleteField(l)}this.validateField(t,"change")},this.resetField=t=>{this.baseStore.setState(i=>({...i,fieldMetaBase:{...i.fieldMetaBase,[t]:z},values:this.options.defaultValues?j(i.values,t,P(this.options.defaultValues,t)):i.values}))},this.getAllErrors=()=>({form:{errors:this.state.errors,errorMap:this.state.errorMap},fields:Object.entries(this.state.fieldMeta).reduce((t,[i,e])=>(Object.keys(e).length&&e.errors.length&&(t[i]={errors:e.errors,errorMap:e.errorMap}),t),{})}),this.parseValuesWithSchema=t=>T.validate({value:this.state.values,validationSource:"form"},t),this.parseValuesWithSchemaAsync=t=>T.validateAsync({value:this.state.values,validationSource:"form"},t),this.baseStore=new nt(H({...a?.defaultState,values:a?.defaultValues??a?.defaultState?.values})),this.fieldMetaDerived=new G({deps:[this.baseStore],fn:({prevDepVals:t,currDepVals:i,prevVal:e})=>{const s=e,o=t?.[0],l=i[0];let d=0;const m={};for(const h of Object.keys(l.fieldMetaBase)){const u=l.fieldMetaBase[h],n=o?.fieldMetaBase[h],c=s?.[h],M=P(l.values,h);let f=c?.errors;if(!n||u.errorMap!==n.errorMap){f=Object.values(u.errorMap??{}).filter(V=>V!==void 0);const S=this.getFieldInfo(h)?.instance;S&&!S.options.disableErrorFlat&&(f=f?.flat(1))}const v=!mt(f??[]),g=!u.isDirty,p=D(M,P(this.options.defaultValues,h))||D(M,this.getFieldInfo(h)?.instance?.options.defaultValue);if(c&&c.isPristine===g&&c.isValid===v&&c.isDefaultValue===p&&c.errors===f&&u===n){m[h]=c,d++;continue}m[h]={...u,errors:f,isPristine:g,isValid:v,isDefaultValue:p}}return Object.keys(l.fieldMetaBase).length&&s&&d===Object.keys(l.fieldMetaBase).length?s:m}}),this.store=new G({deps:[this.baseStore,this.fieldMetaDerived],fn:({prevDepVals:t,currDepVals:i,prevVal:e})=>{const s=e,o=t?.[0],l=i[0],d=i[1],m=Object.values(d).filter(Boolean),h=m.some(y=>y.isValidating),u=m.every(y=>y.isValid),n=m.some(y=>y.isTouched),c=m.some(y=>y.isBlurred),M=m.every(y=>y.isDefaultValue),f=n&&l.errorMap?.onMount,v=m.some(y=>y.isDirty),g=!v,p=!!(l.errorMap?.onMount||m.some(y=>y?.errorMap?.onMount)),S=!!h;let V=s?.errors??[];(!o||l.errorMap!==o.errorMap)&&(V=Object.values(l.errorMap).reduce((y,w)=>w===void 0?y:w&&X(w)?(y.push(w.form),y):(y.push(w),y),[]));const A=V.length===0,E=u&&A,L=this.options.canSubmitWhenInvalid??!1,F=l.submissionAttempts===0&&!n&&!p||!S&&!l.isSubmitting&&E||L;let I=l.errorMap;if(f&&(V=V.filter(y=>y!==l.errorMap.onMount),I=Object.assign(I,{onMount:void 0})),s&&o&&s.errorMap===I&&s.fieldMeta===this.fieldMetaDerived.state&&s.errors===V&&s.isFieldsValidating===h&&s.isFieldsValid===u&&s.isFormValid===A&&s.isValid===E&&s.canSubmit===F&&s.isTouched===n&&s.isBlurred===c&&s.isPristine===g&&s.isDefaultValue===M&&s.isDirty===v&&D(o,l))return s;let B={...l,errorMap:I,fieldMeta:this.fieldMetaDerived.state,errors:V,isFieldsValidating:h,isFieldsValid:u,isFormValid:A,isValid:E,canSubmit:F,isTouched:n,isBlurred:c,isPristine:g,isDefaultValue:M,isDirty:v};const x=this.options.transform?.deps??[];if(x.length!==this.prevTransformArray.length||x.some((y,w)=>y!==this.prevTransformArray[w])){const y=Object.assign({},this,{state:B});this.options.transform?.fn(y),B=y.state,this.prevTransformArray=x}return B}}),this.handleSubmit=this.handleSubmit.bind(this),this.update(a||{})}get state(){return this.store.state}get formId(){return this.options.formId}runValidator(a){return at(a.validate)?T[a.type](a.value,a.validate):a.validate(a.value)}async handleSubmit(a){if(this.baseStore.setState(e=>({...e,isSubmitted:!1,submissionAttempts:e.submissionAttempts+1,isSubmitSuccessful:!1})),b(()=>{Object.values(this.fieldInfo).forEach(e=>{e.instance&&(e.instance.state.meta.isTouched||e.instance.setMeta(s=>({...s,isTouched:!0})))})}),!this.state.canSubmit)return;const t=a??this.options.onSubmitMeta;this.baseStore.setState(e=>({...e,isSubmitting:!0}));const i=()=>{this.baseStore.setState(e=>({...e,isSubmitting:!1}))};if(await this.validateAllFields("submit"),!this.state.isFieldsValid){i(),this.options.onSubmitInvalid?.({value:this.state.values,formApi:this,meta:t});return}if(await this.validate("submit"),!this.state.isValid){i(),this.options.onSubmitInvalid?.({value:this.state.values,formApi:this,meta:t});return}b(()=>{Object.values(this.fieldInfo).forEach(e=>{e.instance?.options.listeners?.onSubmit?.({value:e.instance.state.value,fieldApi:e.instance})})}),this.options.listeners?.onSubmit?.({formApi:this,meta:t});try{await this.options.onSubmit?.({value:this.state.values,formApi:this,meta:t}),b(()=>{this.baseStore.setState(e=>({...e,isSubmitted:!0,isSubmitSuccessful:!0})),i()})}catch(e){throw this.baseStore.setState(s=>({...s,isSubmitSuccessful:!1})),i(),e}}setErrorMap(a){b(()=>{Object.entries(a).forEach(([t,i])=>{const e=t;if(X(i)){const{formError:s,fieldErrors:o}=U(i);for(const l of Object.keys(this.fieldInfo))this.getFieldMeta(l)&&this.setFieldMeta(l,m=>({...m,errorMap:{...m.errorMap,[e]:o?.[l]},errorSourceMap:{...m.errorSourceMap,[e]:"form"}}));this.baseStore.setState(l=>({...l,errorMap:{...l.errorMap,[e]:s}}))}else this.baseStore.setState(s=>({...s,errorMap:{...s.errorMap,[e]:i}}))})})}}function U(r){if(r){if(X(r)){const a=U(r.form).formError,t=r.fields;return{formError:a,fieldErrors:t}}return{formError:r}}return{formError:void 0}}function C(r){switch(r){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"dynamic":return"onDynamic";case"change":default:return"onChange"}}class gt{constructor(a){this.options={},this.mount=()=>{const t=this.store.mount();this.options.defaultValue!==void 0&&this.form.setFieldValue(this.name,this.options.defaultValue,{dontUpdateMeta:!0});const i=this.getInfo();i.instance=this,this.update(this.options);const{onMount:e}=this.options.validators||{};if(e){const s=this.runValidator({validate:e,value:{value:this.state.value,fieldApi:this,validationSource:"field"},type:"validate"});s&&this.setMeta(o=>({...o,errorMap:{...o?.errorMap,onMount:s},errorSourceMap:{...o?.errorSourceMap,onMount:"field"}}))}return this.options.listeners?.onMount?.({value:this.state.value,fieldApi:this}),t},this.update=t=>{this.options=t;const i=this.name!==t.name;if(this.name=t.name,this.state.value===void 0){const e=P(t.form.options.defaultValues,t.name),s=t.defaultValue??e;i?this.setValue(o=>o||s,{dontUpdateMeta:!0}):s!==void 0&&this.setValue(s,{dontUpdateMeta:!0})}this.form.getFieldMeta(this.name)===void 0&&this.setMeta(this.state.meta)},this.getValue=()=>this.form.getFieldValue(this.name),this.setValue=(t,i)=>{this.form.setFieldValue(this.name,t,i),this.triggerOnChangeListener(),this.validate("change")},this.getMeta=()=>this.store.state.meta,this.setMeta=t=>this.form.setFieldMeta(this.name,t),this.getInfo=()=>this.form.getFieldInfo(this.name),this.pushValue=(t,i)=>{this.form.pushFieldValue(this.name,t,i),this.triggerOnChangeListener()},this.insertValue=(t,i,e)=>{this.form.insertFieldValue(this.name,t,i,e),this.triggerOnChangeListener()},this.replaceValue=(t,i,e)=>{this.form.replaceFieldValue(this.name,t,i,e),this.triggerOnChangeListener()},this.removeValue=(t,i)=>{this.form.removeFieldValue(this.name,t,i),this.triggerOnChangeListener()},this.swapValues=(t,i,e)=>{this.form.swapFieldValues(this.name,t,i,e),this.triggerOnChangeListener()},this.moveValue=(t,i,e)=>{this.form.moveFieldValues(this.name,t,i,e),this.triggerOnChangeListener()},this.clearValues=t=>{this.form.clearFieldValues(this.name,t),this.triggerOnChangeListener()},this.getLinkedFields=t=>{const i=Object.values(this.form.fieldInfo),e=[];for(const s of i){if(!s.instance)continue;const{onChangeListenTo:o,onBlurListenTo:l}=s.instance.options.validators||{};t==="change"&&o?.includes(this.name)&&e.push(s.instance),t==="blur"&&l?.includes(this.name)&&e.push(s.instance)}return e},this.validateSync=(t,i)=>{const e=J(t,{...this.options,form:this.form,validationLogic:this.form.options.validationLogic||O}),o=this.getLinkedFields(t).reduce((m,h)=>{const u=J(t,{...h.options,form:h.form,validationLogic:h.form.options.validationLogic||O});return u.forEach(n=>{n.field=h}),m.concat(u)},[]);let l=!1;b(()=>{const m=(h,u)=>{const n=K(u.cause),c=u.validate?it(h.runValidator({validate:u.validate,value:{value:h.store.state.value,validationSource:"field",fieldApi:h},type:"validate"})):void 0,M=i[n],{newErrorValue:f,newSource:v}=tt({formLevelError:M,fieldLevelError:c});h.state.meta.errorMap?.[n]!==f&&h.setMeta(g=>({...g,errorMap:{...g.errorMap,[n]:f},errorSourceMap:{...g.errorSourceMap,[n]:v}})),f&&(l=!0)};for(const h of e)m(this,h);for(const h of o)h.validate&&m(h.field,h)});const d=K("submit");return this.state.meta.errorMap?.[d]&&t!=="submit"&&!l&&this.setMeta(m=>({...m,errorMap:{...m.errorMap,[d]:void 0},errorSourceMap:{...m.errorSourceMap,[d]:void 0}})),{hasErrored:l}},this.validateAsync=async(t,i)=>{const e=Q(t,{...this.options,form:this.form,validationLogic:this.form.options.validationLogic||O}),s=await i,o=this.getLinkedFields(t),l=o.reduce((n,c)=>{const M=Q(t,{...c.options,form:c.form,validationLogic:c.form.options.validationLogic||O});return M.forEach(f=>{f.field=c}),n.concat(M)},[]);this.state.meta.isValidating||this.setMeta(n=>({...n,isValidating:!0}));for(const n of o)n.setMeta(c=>({...c,isValidating:!0}));const d=[],m=[],h=(n,c,M)=>{const f=K(c.cause);n.getInfo().validationMetaMap[f]?.lastAbortController.abort();const g=new AbortController;this.getInfo().validationMetaMap[f]={lastAbortController:g},M.push(new Promise(async p=>{let S;try{S=await new Promise((F,I)=>{this.timeoutIds.validations[c.cause]&&clearTimeout(this.timeoutIds.validations[c.cause]),this.timeoutIds.validations[c.cause]=setTimeout(async()=>{if(g.signal.aborted)return F(void 0);try{F(await this.runValidator({validate:c.validate,value:{value:n.store.state.value,fieldApi:n,signal:g.signal,validationSource:"field"},type:"validateAsync"}))}catch(B){I(B)}},c.debounceMs)})}catch(F){S=F}if(g.signal.aborted)return p(void 0);const V=it(S),A=s[this.name]?.[f],{newErrorValue:E,newSource:L}=tt({formLevelError:A,fieldLevelError:V});n.setMeta(F=>({...F,errorMap:{...F?.errorMap,[f]:E},errorSourceMap:{...F.errorSourceMap,[f]:L}})),p(E)}))};for(const n of e)n.validate&&h(this,n,d);for(const n of l)n.validate&&h(n.field,n,m);let u=[];(d.length||m.length)&&(u=await Promise.all(d),await Promise.all(m)),this.setMeta(n=>({...n,isValidating:!1}));for(const n of o)n.setMeta(c=>({...c,isValidating:!1}));return u.filter(Boolean)},this.validate=(t,i)=>{if(!this.state.meta.isTouched)return[];const{fieldsErrorMap:e}=i?.skipFormValidation?{fieldsErrorMap:{}}:this.form.validateSync(t),{hasErrored:s}=this.validateSync(t,e[this.name]??{});if(s&&!this.options.asyncAlways)return this.getInfo().validationMetaMap[K(t)]?.lastAbortController.abort(),this.state.meta.errors;const o=i?.skipFormValidation?Promise.resolve({}):this.form.validateAsync(t);return this.validateAsync(t,o)},this.handleChange=t=>{this.setValue(t)},this.handleBlur=()=>{this.state.meta.isTouched||this.setMeta(i=>({...i,isTouched:!0})),this.state.meta.isBlurred||this.setMeta(i=>({...i,isBlurred:!0})),this.validate("blur"),this.triggerOnBlurListener()},this.parseValueWithSchema=t=>T.validate({value:this.state.value,validationSource:"field"},t),this.parseValueWithSchemaAsync=t=>T.validateAsync({value:this.state.value,validationSource:"field"},t),this.form=a.form,this.name=a.name,this.timeoutIds={validations:{},listeners:{},formListeners:{}},this.store=new G({deps:[this.form.store],fn:()=>{const t=this.form.getFieldValue(this.name),i=this.form.getFieldMeta(this.name)??{...z,...a.defaultMeta};return{value:t,meta:i}}}),this.options=a}get state(){return this.store.state}runValidator(a){return at(a.validate)?T[a.type](a.value,a.validate):a.validate(a.value)}setErrorMap(a){this.setMeta(t=>({...t,errorMap:{...t.errorMap,...a}}))}triggerOnBlurListener(){const a=this.form.options.listeners?.onBlurDebounceMs;a&&a>0?(this.timeoutIds.formListeners.blur&&clearTimeout(this.timeoutIds.formListeners.blur),this.timeoutIds.formListeners.blur=setTimeout(()=>{this.form.options.listeners?.onBlur?.({formApi:this.form,fieldApi:this})},a)):this.form.options.listeners?.onBlur?.({formApi:this.form,fieldApi:this});const t=this.options.listeners?.onBlurDebounceMs;t&&t>0?(this.timeoutIds.listeners.blur&&clearTimeout(this.timeoutIds.listeners.blur),this.timeoutIds.listeners.blur=setTimeout(()=>{this.options.listeners?.onBlur?.({value:this.state.value,fieldApi:this})},t)):this.options.listeners?.onBlur?.({value:this.state.value,fieldApi:this})}triggerOnChangeListener(){const a=this.form.options.listeners?.onChangeDebounceMs;a&&a>0?(this.timeoutIds.formListeners.change&&clearTimeout(this.timeoutIds.formListeners.change),this.timeoutIds.formListeners.change=setTimeout(()=>{this.form.options.listeners?.onChange?.({formApi:this.form,fieldApi:this})},a)):this.form.options.listeners?.onChange?.({formApi:this.form,fieldApi:this});const t=this.options.listeners?.onChangeDebounceMs;t&&t>0?(this.timeoutIds.listeners.change&&clearTimeout(this.timeoutIds.listeners.change),this.timeoutIds.listeners.change=setTimeout(()=>{this.options.listeners?.onChange?.({value:this.state.value,fieldApi:this})},t)):this.options.listeners?.onChange?.({value:this.state.value,fieldApi:this})}}function it(r){if(r)return r}function K(r){switch(r){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"dynamic":return"onDynamic";case"change":default:return"onChange"}}const N=typeof window<"u"?$.useLayoutEffect:$.useEffect;function pt(r){const[a]=$.useState(()=>{const i=new gt({...r,form:r.form,name:r.name});return i.Field=ot,i});return N(a.mount,[a]),N(()=>{a.update(r)}),st(a.store,r.mode==="array"?t=>[t.meta,Object.keys(t.value??[]).length]:void 0),a}const ot=({children:r,...a})=>{const t=pt(a),i=$.useMemo(()=>R(r,t),[r,t,t.state.value,t.state.meta]);return k.jsx(k.Fragment,{children:i})};function yt({form:r,selector:a,children:t}){const i=st(r.store,a);return R(t,i)}function At(r){const[a]=$.useState(()=>{const t=new Mt(r),i=t;return i.Field=function(s){return k.jsx(ot,{...s,form:t})},i.Subscribe=function(s){return k.jsx(yt,{form:t,selector:s.selector,children:s.children})},i});return N(a.mount,[]),N(()=>{a.update(r)}),a}export{bt as C,Et as a,At as u};
